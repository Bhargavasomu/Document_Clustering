A Better Strategy of Discovering Link-Pattern Based 

Communities by Classical Clustering Methods 

Chen-Yi Lin1, Jia-Ling Koh2, and Arbee L.P. Chen3 

1 Department of Computer Science, National Tsing Hua University, Hsinchu, Taiwan 

d9562820@oz.nthu.edu.tw 

2 Department of Computer Science and Information Engineering, 

National Taiwan Normal University, Taipei, Taiwan 

jlkoh@csie.ntnu.edu.tw 

3 Department of Computer Science, National Chengchi University, Taipei, Taiwan 

alpchen@cs.nccu.edu.tw 

Abstract. The definition of a community in social networks varies with appli-
cations.  To  generalize  different  types  of  communities,  the  concept  of  link-
pattern based community was proposed in a previous study to group nodes into 
communities,  where  the  nodes  in  a  community  have  similar  intra-community 
and inter-community interaction behaviors. In this paper, by defining centroid 
of a community, a distance  function is provided to measure the  similarity be-
tween the link pattern of a node and the centroid of a community. The problem 
of discovering link-pattern based communities is transformed into a data clus-
tering problem on nodes for minimizing a given objective function. By extend-
ing the partitioning methods of cluster analysis, two algorithms named G-LPC 
and KM-LPC are proposed to solve the problem. The experiment results show 
that KM-LPC outperforms the previous work on the efficiency, the memory uti-
lization,  and  the  clustering  result.  Besides,  G-LPC  achieves  the  best  result  
approaching the optimal solution. 

Keywords:  Social  Network,  Link-Pattern  based  Community,  Clustering  
Algorithms. 

1   Introduction 

Social network analysis is an established field in sociology. A social network is most-
ly modeled by a graph in which a node represents an individual and an edge between 
two  nodes  denotes  a  social  interaction  between  the  corresponding  individuals.  In 
recently  years,  because  of  the  increasing  availability  of  social  network  data  on  the 
Web  2.0  platform,  the  study  of  social  network  analysis  has  emerged  into  an  active 
research field. The community structure is an important topological characteristic of 
social networks,  which provides a basis  for further analysis of  social networks.  Ac-
cordingly, discovering the communities from a social network has become an essen-
tial problem on social network analysis. 

The definitions of a community in social networks vary with applications. In most 
studies,  finding  groups  of  nodes  within  which  the  interconnections  are  dense  but  

M.J. Zaki et al. (Eds.): PAKDD 2010, Part I, LNAI 6118, pp. 56–67, 2010. 
© Springer-Verlag Berlin Heidelberg 2010 

 

A Better Strategy of Discovering Link-Pattern Based Communities 

57 

between which the interconnections are sparse is attractive to users. In earlier papers, 
the  graph  partitioning  techniques  were  adopted  to  divide  nodes  into  subsets  by  dis-
covering the various kinds of cuts in a graph such as average cuts [1], normalized cuts 
[9],  min-max  cuts  [2],  and  maximum  flow/minimum  cuts  [3,  5].  However,  in  some 
applications such as those in blogosphere, a group of individuals linking to the same 
set of blogs indicates a set of latent friends with common interests even though they 
sparsely link to each other [6, 8]. Therefore, to generalize the different types of com-
munities, the concept of link-pattern based community was proposed in [7]. 

A link-pattern based community is a group of nodes which have a similar link pat-
terns,  i.e.,  the  nodes  in  the  same  community  have  similar  intra-community  and  inter-
community interaction behaviors. For example, the individuals, denoted by the nodes 
in Figure 1, are grouped into three communities: C1 = {v1, v2, v3, v4}, C2 = {v5, v6, v7, 
v8}, and C3 = {v9, v10, v11, v12}. The nodes in C1 link densely to each other, link moder-
ately to the nodes in C2, and link sparsely to the nodes in C3. On the other hand, the 
nodes in C2 link moderately to the nodes in C1 and link sparsely to the nodes in both 
C2  and  C3.  The  nodes  in  C3  also  link  to  other  nodes  within  the  community  and  be-
tween the communities in similar ways. The concept of a community prototype graph 
was also proposed, which consists of a set of community nodes (i.e., C1, C2 and C3 in 
Figure  1)  and  a  set  of  edges  among  community  nodes  to  represent  the  community 
structures. Accordingly, the graph and its community prototype graph are represented 
as affinity matrices in which each entry represents the weight of an edge between two 
corresponding nodes. An iterative algorithm named CLGA was developed to find the 
optimal  community  prototype  graph  from  the  graph  by  solving  the  optimization  
problem of matrix approximation. 

C1 

2

3

1 

C2 

5 

6

7

C3 
10

9

11

12

 

4

8

Fig. 1. An example of the link-pattern based communities 

The number of individuals in a social network is enormous in most cases, and the 
size  of  the  affinity  matrix  of  the  original  graph  is  determined  by  the  number  of  
individuals. Consequently, the algorithms for solving the problem of discovering the 
link-pattern based communities are challenging on the requirement of memory usage 
and the performance efficiency. However, in [7], in order to find the optimal commu-
nity prototype graph, it requires exhaustive search by moving a node from one com-
munity  to  another  community.  In  each  time  of  iteration,  the  affinity  matrix  of  the 
corresponding community prototype graph has to be recomputed. As a result, CLGA 
is computationally infeasible. Besides, CLGA has to  maintain the affinity  matrix of 
the community prototype graph. Consequently, the memory requirement of CLGA is 
at least double of the one required by the affinity matrix of the original graph. 

According  to  the  concept  of  the  link-pattern  based  community,  the  edges  with 
weights incident to a node are essential features which imply the link-pattern of the 

58 

C.-Y. Lin, J.-L. Koh, and A.L.P. Chen 

node. In this paper, we reformulate the problem based on the proximity of the links of 
nodes to discover the link-pattern based community structures, and evaluate the qual-
ity of the community structures according to the similarity of the weights of the intra-
links  within  a  community  and  that  of  the  weights  of  the  inter-links  between  the  
community and every other community. It is proved that the reformulated problem of 
communities discovering is equivalent to the problem defined in [7]. In order to get a 
good clustering result, two different strategies are provided to select sample nodes for 
determining  the  initial  the  communities.  Based  on  the  extracted  initial  community 
structures, two algorithms, named G-LPC and KM-LPC, based on the classical clus-
tering  methods,  are  provided  to  discover  the  communities.  The  experiment  results 
show that KM-LPC outperforms CLGA not only on the efficiency and memory utili-
zation, but also on the clustering result. Although G-LPC requires the most computa-
tional cost than the others, it achieves the best result approaching the optimal solution. 
The  remaining  sections  of  this  paper  are  organized  as  follows.  The  reformulated 
problem and the proposed algorithms are described in Sections 2 and 3, respectively. 
The  performance  study  is  reported  in  Section  4,  which  shows  the  effectiveness,  
efficiency,  and  memory  usage  of  the  proposed  methods.  Finally,  in  Section  5,  we 
conclude this paper and discuss directions for our future studies. 

2   Preliminaries 

In  this  section,  the  problem  proposed  in  [7]  for  discovering  the  link-pattern  based 
communities  is  introduced  briefly.  Then  we  reformulate  the  problem  and  provide 
solutions to the problem in Section 3. 

2.1   Problem of Matrix Approximation Optimization 

Suppose  an  undirected  weighted  graph  G  =  (V,  E,  A)  is  given,  where  V  is  a  set  of 
nodes {v1, v2, …, vn}, E is a set of edges (vi, vj), and A is the affinity matrix of G. A is 
an n×n symmetric matrix, in which A[i, j] is a positive value representing the weight 
of the edge between nodes vi and vj if (vi, vj) ∈ E; otherwise, A[i, j] is set to be 0. 

A community prototype graph defined in [7] consists of a set of community nodes 
and a set of edges among community nodes associated with weights to represent the 
community structures. Let K denote the number of communities specified by the us-
ers. The community structure matrix B is a K×K matrix for representing the weights of 
intra-links  and  inter-links  of  the  community  nodes.  Besides,  an  n×K  matrix  C  with 
binary  values  denotes  the  community  membership  of  each  node,  where  each  node 
belongs to exact one community and there is no empty community. The affinity ma-
trix  of  a  community  prototype  graph,  denoted  as  A',  is  an  n×n  matrix  which  is  the 
result  of  CBCT.  Accordingly,  the  challenge  of  discovering  the  link-pattern  based 
communities is how to find C and B such that ||A - A'||2 is minimized. 
[Example 2.1]. The nodes of the social network shown in Figure 2(a) are required to 
be grouped into two link-pattern based communities. The affinity matrix of the corre-
sponding graph is shown as Figure 2(b). When the two communities are constructed 
as C1 = {v1, v2, v3, v4} and C2 = {v5, v6, v7, v8}, the corresponding community proto-
type graph shown in Figure 2(c) is the optimal solution of this case. Accordingly, the 

 

A Better Strategy of Discovering Link-Pattern Based Communities 

59 

4 

corresponding matrices C and B of the constructed community structures are shown in 
Figure 2(d). Besides, the affinity matrix of the community prototype graph is shown 
as Figure 2(e). Therefore, the difference between the affinity matrix of the graph and 
the affinity matrix of the community prototype graph is 3.5. 
 
 
1 
 
2 
 
 
5 
 
6 
 
   (a)                  (b)                         (c)                      (d)                                          (e) 

1  2 3 4 5  6  7  8 
1  1  1 1 1 0  0  0  0 
2  1  1 1 1 0  0  0  1 
3  1  1 1 1 1  0  0  0 
4  1  1 1 1 0  0  0  0 
5  0  0 1 0 1  1  1  1 
6  0  0 0 0 1  1  1  1 
7  0  0 0 0 1  1  1  1 
8  0  1 0 0 1  1  1  1 

1
2
3
4
5 0.125 0.125 0.125 0.125
6 0.125 0.125 0.125 0.125
7 0.125 0.125 0.125 0.125
8 0.125 0.125 0.125 0.125

0.125  0.125  0.125  0.125 
0.125  0.125  0.125  0.125 
0.125  0.125  0.125  0.125 
0.125  0.125  0.125  0.125 

1 
1 
1 
1 
1 

3 
1 
1 
1 
1 

2 
1 
1 
1 
1 

4 
1 
1 
1 
1 

0
0
0
0
1
1
1
1

1
1
1
1
0
0
0
0

1 
1 
1 
1 

1 
1 
1 
1 

1 
1 
1 
1 

1 
1 
1 
1 

0.125 

0.125

0.125

B = 

C= 

C1 

C2 

7 

8 

1 

2 

3 

4 

1 

1 

5 

6 

7 

8 

8 

7 

3 

5 

6 

1

1

Fig. 2. An example of a graph and its optimal community prototype graph 

2.2   Problem Definition 

Based on the definition of the link-pattern based community, a good solution of the 
problem tends to group the nodes with similar intra-community and inter-community 
interaction behaviors into the same community. The link pattern of a node is charac-
terized by its edges linked to other nodes, and the link pattern of a community by the 
aggregate link patterns of the nodes in the community. An object function is designed 
to evaluate the quality of the communities by the distance between the link patterns of 
each community and its nodes. 

2

nu

,

,

,

,

,

,

=

v
u

v
u

K

K

}

{

}

{

C
v

v
v
1

v
u
1

v
v
2

v
v
nv

 and 

Suppose  the  members  in  each  community  have  been  assigned.  Let 
=
 denote  two  communities,  where  nu 
C
u
and  nv  denote  the  number  of  nodes  in  Cu  and  Cv,  respectively.  The  affinity  matrix  for 
uCA ,  is  an  nu×nu  sub-matrix  of  A  which  is  the  affinity  matrix 
the  nodes  in  Cu,  denoted 
iuv  is  represented  by  the  ith 
of  the  original  graph.  The  intra-community  link  pattern  of 
iuv .  Moreover,  the 
row  in 
 for  the  nodes  in  Cu  with  the  nodes  in  Cv  is  an  nu×nv  sub-matrix 
affinity  matrix 
of  A,  in  which  the  ith  row  represents  the  inter-community  edges  of 
iuv  with  the  nodes 
in Cv. 

uCA  with  the  weights  of  the  intra-community  edges  of 

C CA
,u

Consequently, the intra-community pattern of the community Cu is represented by 
a vector of nu dimensions where each dimension contains the average weight of the 
intra-community link patterns of all the nodes in Cu as the following formula shows: 

v

AVG
C
u

=

n
u

n
u

∑∑
=
1
j
n
u

=
1

i

[
A i
C
u

,

]

j

×

n
u

                                                     (1) 

The inter-community pattern of the community Cu with Cv is represented by a vector 
of  nv  dimensions  where  each  dimension  contains  the  average  weight  of  the  inter-
community edges of all the nodes in Cu with Cv as the following formula shows: 

AVG

C C
v

u

,

=

[

i

,

j

]

v

A
C C

,

u

n
u

n
v

∑∑
=
1
n
u

=
1

i

j

×

n
v

                                                   (2) 

60 

C.-Y. Lin, J.-L. Koh, and A.L.P. Chen 

Therefore, the intra-distance of Cu and the inter-distance between Cu and Cv are de-
fined by the following formulas: 

SSD
C
u

=

SSD

C C
v

u

,

=

n
u

n
u

j

i

=
1

=
1

∑∑
(

∑∑

n
u

n
v

=
1

i

=
1

j

(

[
A i
C
u

,

]

j

−

AVG
C
u

)2

                                          (3) 

[

i

,

j

]

−

A
C C
v

u

,

AVG

C C
v

u

,

)2

                                      (4) 

[Example 2.2]. The nodes of the graph shown in Figure 2(a) are grouped into C1 and 
 are  shown 
C2.  Consequently,  the  corresponding  matrices 
AVG , 
in  Figure  3(a),  (b),  (c),  and  (d),  respectively.  Accordingly,  the  values  of 
 are  1,  1,  0.125,  and 0.125,  respectively.  Besides,  the 
AVG , 
, and 
values of 

 are 0, 0, 1.75, and 1.75, respectively. 

2,C C
1
SSD , 

,  and 
SSD , 

AVG
SSD

,  and 

1,C CA

2,C CA

2CA , 

1CA , 

AVG

SSD

1,C C

2C

1C

2

1

2

1C

2C

2,C C
1

1,C C

2

  1  2  3  4 
1 1  1  1  1 

 

6

5

8
5 1  1  1  1 

7

6

5

8
1 0  0  0  0 

7

2

1

4
5 0  0  1  0 

3

2 1  1  1  1 

6 1  1  1  1 

2 0  0  0  1 

6 0  0  0  0 

3 1  1  1  1 

7 1  1  1  1 

3 1  0  0  0 

7 0  0  0  0 

4 1  1  1  1 

8 1  1  1  1 

4 0  0  0  0 

8 0  1  0  0 

(a)                  (b)                  (c)                  (d) 

Fig. 3. The affinity matrices 

1CA , 

2CA , 

2,C CA

1

, and 

1,C CA

2

 

Consequently, the problem of discovering the link-pattern based communities from 
a social network is formulated by minimizing the sum of the intra- and inter-distances 
of the communities as the following. According to a given positive integer K which 
denotes  the  number  of  communities,  the  optimized  communities  are  given  by 
minimizing the following objective function: 

arg min
,
,
K

C C

1

2

,

C

K

K

∑

=
1

i

⎛
⎜
⎝

SSD
C
i

+

j

K

∑

= ∧ ≠
1

j

i

SSD

C C

,

i

                                         (5) 

⎞
⎟
⎠

j

where the n nodes in the social network are separated into C1, …, CK such that each 
node belongs to exact one community. Besides, there is no empty community allowed. 
It is deducible that the optimal solution discovered according to the proposed ob-
jective function is the same as the one discovered by CLGA. Suppose the members in 
each community have been assigned. Based on our observation on matrix B, the di- 
AVG  and the non-diagonal entry B[i, j] in B is equal 
agonal entry B[i, i] is equal to 
AVG . Therefore, for any pair of vx and vy in  Ci, the entry A'[x,  y] in  A' of the 
to 
AVG . On the other hand, the entry A'[x, y] is 
community prototype graph is equal to 
AVG  for any node vx in Ci and node vy in Cj. Since each node belongs to 
equal to 
exact one community, ||A – A'||2 is equal to 

,i
C C

,i
C C

. 

iC

iC

K

K

j

j

∑

=
1

i

⎛
⎜
⎝

SSD
C
i

+

∑

= ∧ ≠
1

j

i

j

SSD

C C

,

i

j

⎞
⎟
⎠

3   The Proposed Algorithms 

According to the objective function defined in Section 2, the task of discovering the 
link-pattern  based  communities  is  an  optimization  problem  of  minimizing  the  

 

A Better Strategy of Discovering Link-Pattern Based Communities 

61 

objective  function.  However,  it  is  computationally  infeasible  to  exhaustively  search 
the  global  optimum  solution  of  this  problem.  To  provide  a  heuristic  algorithm  for 
solving this problem, a greedy based algorithm and a K-Means based algorithm are 
proposed to discover the disjoint clusters of data nodes which correspond to the link-
pattern based communities of these nodes. 

3.1   Basic Idea 

In order to get a value of the objective function as small as possible, one effective way 
is to adopt the greedy-based algorithm in which each node is iteratively assigned to a 
community such that the obtained value of the objective function is minimal. The K-
Means algorithm [4] is a typical method of cluster analysis. The goal of K-Means is to 
minimize the sum of squared distances between data and the mean of the correspond-
ing cluster, which is similar to the goal of the objective function defined in this paper. 
Therefore, a K-Means based algorithm is also proposed to discover the communities. 

According to the given information of graph G, row i in the affinity matrix A of G 
provides the information of the link pattern of node vi, which forms the feature vector 
of vi. For a community Cu, the feature vector of Cu is an n-dimensional vector. The jth 
dimension in the feature vector of Cu contains the value of 
AVG  if node vj belongs 
to Cu; otherwise, it contains the value of 
 if node vj belongs to another com- 
munity Cv. During the progressive process of clustering, the feature vector of a com-
munity will be used to be its centroid. Therefore, the value of the objective function 
defined in formula (5) corresponds to the sum of squared distance between the feature 
vector of each node and the centroid of its community. 

AVG

uC

,u
C C
v

To adopt the clustering methods for discovering the communities, first, K initial cen-
troids are determined by performing a clustering on the sample nodes selected from the 
social network. Next, each node in the social network is assigned to a community by 
executing  one  of  the proposed  two  algorithms. The  centroid  of  a community  will  be 
updated according to the nodes assigned to the community. Relative to the new cen-
troids, the above process is repeated until there is no change in communities. 

3.2   Determining Initial Centroids 

In terms of the quality of the clustering result, determining a set of appropriate initial 
centroids of clusters is the key step of clustering algorithms. However, it is not easy to 
determine  a  ‘good’  set  of  initial  centroids  of  clusters  without  knowing  the  connec-
tivity  among  the  nodes.  Therefore,  some  sample  nodes  are  chosen  from  the  graph. 
Then  the  agglomerative  hierarchical  clustering  method  is  adopted  to  separate  these 
sample nodes into K disjoint clusters. Finally, the mean of the feature vectors of the 
sample nodes assigned to a cluster is set as the initial centroid of the cluster. 

A  straightforward  method  is  to  choose  the  sample  nodes  randomly.  However,  a 
good  quality  of  the  clustering  result  is  obtained  by  chance  based  on  which  sample 
nodes  are  chosen. In  order  to  understand  the  characteristics of  the link-pattern  based 
communities in a real dataset, the Enron email dataset is analyzed by CLGA. It is ob-
served  that  the  nodes  which  are distributed  to the  same  community  usually  have  the 
similar degrees. In other words, it is more possible that two nodes belong to the same 
community as their degrees are closer. Accordingly, in our second strategy, the sample 

62 

C.-Y. Lin, J.-L. Koh, and A.L.P. Chen 

nodes are selected based on the degrees of the nodes. Moreover, the number of chosen 
sample nodes is determined by K×U, where K is the number of expected communities 
and U is a user-specified integer which is at least one and less than ⎣n/K⎦. 

By summarizing the above considerations, the following two strategies are used to 

select sample nodes from the given graph G. 
(1) Picking by random 

K×U sample nodes are chosen from G randomly without replacement. 

(2) Picking by node degree 

The nodes  with  the identical  degree are assigned to the same  group. Within each 

group, U nodes are chosen randomly without replacement. 

After selecting sample nodes by one of the above-mentioned strategies, the sample 
nodes  are  separated  into  K  clusters  by  the  agglomerative  hierarchical  clustering.  At 
the beginning, each sample node is considered as an individual cluster. Let cx and cy 
denote the centroids of two clusters Cx and Cy, respectively. The distance between Cx 
and Cy is decided by calculating the Euclidean distance between cx and cy: 

(

)

dist C C

,x

y

=

−

c

y

c

x

                                                (6) 

Iteratively, two nearest clusters are chosen to be merged into a cluster until K clusters 
remain. Whenever two clusters are merged to generate a new cluster Cl, the centroid 
of Cl, which is denoted as cl, is obtained according to the following formula: 

c
l

1
= ∑
n
l

∈
SN C
l

SN fv

.

                                                        (7) 

where nl denotes the number of sample nodes in Cl, SN denotes a sample node in Cl, 
and SN.fv denotes the feature vector of the sample node. 

[Example 3.1]. In the graph shown in Figure 2(a), the number of distinct degree values 
of nodes is 2. By using the picking by node degree strategy to select sample nodes, the 
nodes  in  the  graph  are  separated  into  two  groups  {v1,  v4,  v6,  v7}  and  {v2,  v3,  v5,  v8}. 
When U is set as 1, the number of chosen sample nodes from each group is 1. Suppose 
nodes v4 and v3 are chosen as the sample nodes. Accordingly, <1, 1, 1, 1, 0, 0, 0, 0> and 
<1, 1, 1, 1, 1, 0, 0, 0> of v4 and v3 are used as the initial centroids of C1 and C2. 

3.3   Communities Discovering 

After the initial centroids of K clusters are obtained, each node in G is then assigned 
to  the  closest  cluster,  and  the  centroid  of  each  cluster  is  updated  according  to  the 
nodes assigned to the cluster. Then two algorithms are proposed to reassign each node 
in G to the clusters iteratively until the result converges. 
(1) Discovering Initial Communities 

According to the initial centroids, each node in the graph G is assigned to the clos-

est cluster one by one. The distance between a node v and Cu is determined: 

(

dist v C
u

,

)

=

.
v fv

−

c
u

                                                       (8) 

where v.fv denotes the feature vector of node v. 

When the assignment of all the nodes to the clusters completes, the initial structures 
of communities are constructed. Accordingly, the feature vector of each initial com-
munity is computed to update its centroid. 

 

A Better Strategy of Discovering Link-Pattern Based Communities 

63 

[Example  3.2]. By continuing the result of Example 3.1, the nodes in the graph are 
separated into two initial clusters  C1 = {v1,  v2,  v4} and  C2  = {v3,  v5,  v6,  v7,  v8}. The 
 are  1,  0.76,  and  0.2667,  respectively. 
values  of 
Therefore,  the  centroids  of  C1  and  C2  are  <1,  1,  0.2667,  1,  0.2667,  0.2667,  0.2667, 
0.2667> and <0.2667, 0.2667, 0.76, 0.2667, 0.76, 0.76, 0.76, 0.76>, respectively. 
(2) The Clustering Algorithms 

AVG ,  and 

AVG , 

AVG

2,C C
1

1C

2C

The two clustering algorithms proposed to discover the community structures ac-

cording to the initial communities are introduced. 

2C

2,C C
1

AVG

(A) The Greedy based Algorithm 
The  process  of  the  Greedy  based  algorithm  for  discovering  Link  Pattern-based 
Communities (abbreviated as G-LPC) aims to distribute a node to the cluster such that 
the objective function is minimized locally. In each time of iteration, one by one, each 
node  is  checked  to  decide  the  cluster  which  the  node  is  assigned  to.  The  node  is 
moved from the cluster, which it was assigned to in last time of iteration, to another 
cluster  if  the  value  of  objective  function  will  be  reduced  after  the  movement.  The 
above process is repeated until there is no change in clusters. 
[Example 3.3]. According to the result of Example 3.2, the two initial clusters are C1 
= {v1, v2, v4} and C2 = {v3, v5, v6, v7, v8}. If we move node v1 from C1 to C2, 
AVG , 
AVG , and 
 are recomputed to be 1, 0.6111, and 0.4167, respectively. Also, 
the centroids of C1 and C2 are updated. Finally, the new value of the objective func-
tion  is  obtained,  which  is  14.3889.  The  value  is  larger  than  the  previous  one,  i.e. 
10.4267; hence, v1 is remained in C1. 
(B) The K-Means based Algorithm 
The  process  of  the  K-Means  based  algorithm  for  discovering  Link  Pattern-based 
Communities (abbreviated as KM-LPC) assigns each node to the cluster whose cen-
troid is nearest to the feature vector of the node. At the end of each time of iteration, 
the centroid of a cluster is recomputed according to the nodes which are assigned to 
the cluster. The above process is repeated until no member of any cluster changes. 
[Example 3.4]. By continuing the result of Example 3.2, the initial centroids of C1 and C2 
are <1, 1, 0.2667, 1, 0.2667, 0.2667, 0.2667, 0.2667> and <0.2667, 0.2667, 0.76, 0.2667, 
0.76, 0.76, 0.76, 0.76>, respectively. The distances between the feature vector <1, 1, 1, 1, 0, 
0, 0, 0> of v1 and the centroids of C1 and C2 are 0.9068 and 1.9953; consequently, v1 is re-
mained in C1. Similarly, other nodes are assigned to the closest clusters. In the end of this 
loop, the members of C1 and C2 are {v1, v2, v3, v4} and {v5, v6, v7, v8}. By KM-LPC, the final 
community result is C1 = {v1, v2, v3, v4} and C2 = {v5, v6, v7, v8}, which is the optimal solution 
of the link-pattern based communities with 2 communities. 

1C

4   Performance Evaluation 

In  order  to  evaluate  the  effectiveness,  efficiency,  and  memory  requirement  of  the 
proposed algorithms, G-LPC and KM-LPC are implemented by MATLAB ver. 7.0.1. 
Furthermore, CLGA [7] is also implemented for comparison. All the experiments are 
performed on a personal computer with the Intel Pentium Core 2 Quad CPU, 2 GB of 
main memory, and running the Microsoft Windows XP. 

64 

C.-Y. Lin, J.-L. Koh, and A.L.P. Chen 

4.1   Datasets 

Two  real  datasets:  Enron  email  DB1 and  DBLP  Bibliography  DB2 are  used  in  the 
following experiments. The Enron email DB contains the emails of 151 employees. 
The dataset is modeled by a graph in which the weight of the edge between two nodes 
is set to be 1 if any one of the corresponding employees has ever sent an email to the 
other; otherwise, the edge weight is set to be 0. On the other hand, the DBLP dataset 
contains  the  publication  information  of  approximate  700,000  authors.  In  order  to 
reduce the size of the dataset, we select the authors who have at least 75 coauthors, 
and the authors who publish more than 10 papers with one of the previously selected 
authors to run the experiments. As a result, only 7,356 authors are selected. Then an 
undirected  weighted graph is constructed, in  which a node represents one of the se-
lected 7,356 authors; in addition, the weight of an edge between two nodes is set to be 
the  number of collaborations  between the two corresponding authors normalized by 
the maximum number of collaborations between any two authors. 

4.2   Results and Discussions 

There are three parts of experiments to be performed. In the first part, the Enron email 
dataset  is  used  to  evaluate  the  quality  of  obtained  communities,  the  execution  time, 
and the memory requirement of the proposed algorithms and the previous work. Next, 
by using the DBLP dataset, the detailed comparisons of the parameters setting in KM-
LPC  are  observed  in  the  second  part  of  experiments.  At  last,  the  properties  of  the 
discovered link pattern-based communities from the DBLP dataset are analyzed. 

4.2.1   Comparison between the Proposed Algorithms and CLGA 
[Exp. 1]. The Enron email dataset is used in this part of experiments. The parameter 
U is set to be 1. In addition, the strategy of picking by node degree is adopted. 

By varying the value of K, the values of the objective function for the communities 
discovered by the proposed two algorithms and CLGA are shown in Figure 4(a). It is 
indicated that the community structures obtained by the two proposed algorithms are 
both better than the one obtained by CLGA. Besides, G-LPC gets the best result. In 
CLGA, if users have no prior knowledge about the social network, the initial setting 
of the community structures is determined by random. The result shows that the ran-
dom setting adopted in CLGA usually results in a poorer result by comparing with our 
algorithms.  Figure  4(b)  shows  the  execution  time  of  the  algorithms,  in  which  the  
execution  time  of  KM-LPC  is  much  less  than  the  time  of  the  others.  It  shows  that 
KM-LPC  provide  a  significant  improvement  for  discovering  the  communities  effi-
ciently. Moreover, the sizes of  memory requirement of the algorithms are shown in 
Figure 4(c). In our algorithms, in addition to the affinity  matrix of the given graph, 
only the centroids of the communities have to be maintained in main memory instead 
of  storing  another  affinity  matrix  of  the  community  prototype  graph  adopted  by 
CLGA. Therefore, both the proposed algorithms require less memory than CLGA. 

                                                           
1 http://www.cs.cmu.edu/~enron/ 
2 http://www.informatik.uni-trier.de/~ley/db/ 

 

A Better Strategy of Discovering Link-Pattern Based Communities 

65 

To decide the community of a node, G-LPC computes the new value of the objec-
tive function for each possible movement of the node. On the other hand, in KM-LPC, 
it  only  computes  the  distance  between  the  feature  vector  of  a  node  and  all  the  cen-
troids  of  communities  to  find  the  community  with  the  nearest  centroid.  As  a  result, 
although G-LPC requires the most computational cost than the others, it achieves the 
better  result  than  the  others  when  the  value  of  K  is  increasing.  Besides,  when  the 
strategy of picking by random is adopted, the performances of our algorithms are also 
better than that of CLGA. Due to space restrictions, the details of this part of experi-
ment are not shown here. 

n
o
i
t
c
n
u
f
 
e
v
i
t
c
e
j
b
o
 
e
h
t
 
f
o
 
e
u
l
a
V

2200
2100
2000
1900
1800
1700
1600
1500
1400

G-LPC
KM-LPC
CLGA

G-LPC
KM-LPC
CLGA

)
s
(
e
m
T

i

500

400

300

200

100

0

)
s
B
K

(
y
r
o
m
e

M

630
550
470
390
310
230
150

6

12

18

G-LPC
KM-LPC
CLGA

24 K

 

18
                          (a)                                                  (b)                                               (c) 

24 K

12

6

 

6

12

18

24 K

 

Fig. 4. Comparisons between our algorithms and CLGA in the Enron email dataset 

4.2.2   Comparison of the Parameters Setting in KM-LPC 
Because  the  number  of  authors  chosen  from  the  DBLP  dataset  is  7,356,  the  graph 
constructed for the dataset is large and complicated. CLGA cannot run on the DBLP 
dataset under limited memory. Thus, in this part of experiments, we will observe the 
effect  of  the  parameters  U  and  K  on  KM-LPC.  Two  versions  of  the  algorithm  are 
implemented where the strategy for selecting the sample nodes adopts the picking by 
random and picking by node degree, individually. 
[Exp. 2]. The parameter U is set to be 1 and the value of K is varied from 100 to 220. 
The results of the objective function of the 2 different versions of KM-LPC are shown 
in Table 1. The bold-faced values shown in the table indicate the better result in the 
two versions of KM-LPC. In most cases, it obtains the better result of the communi-
ties by using the picking by node degree strategy than using the picking by random 
strategy.  However,  since  most  of  the  edge  weights  in  the  graph  are  very  small,  the 
difference  between  the  obtained  objective  function  values  of  these  two  strategies  is 
not obvious. Table 2 shows the execution time of the 2 versions of KM-LPC, in which 
the bold-faced values represent the same  meaning as used in Table 1. According to 
the results, for KM-LPC, the version by adopting the picking by node degree strategy 
runs faster than the one by adopting the picking by random strategy in most cases. 
[Exp.  3].  For a setting of K, the value of U is varied from 1 to 3.  In addition, KM-
LPC  is  performed  by  combined  with  the  picking  by  node  degree  strategy.  Table  3 
shows  that  a  larger  value  of  U  gets  smaller  value  of  the  objective  function  in  most 
cases. That is, for KM-LPC, picking more sample nodes from the graph to determine 
the  initial  centroids  of  the  clusters  is  a  good  strategy  to  get  better  result.  However, 
when the value of  U increases, the number of selected sample nodes increases. The 
cost  of  performing  the  hierarchical  clustering  to  determine  the  initial  centroids  of 
clusters also increases tremendously. Therefore, as the results shown in Figure 5, the 
execution time of KM-LPC substantially increases when the value of U increases. 

66 

C.-Y. Lin, J.-L. Koh, and A.L.P. Chen 

Table  1.  The  values  of  the  objective  function        Table  2.  The  running  time  (sec.)  obtained 
obtained by Exp. 2                                                      by Exp. 2 

K

Algo. 

KM-LPC 
(Random) 

100 

115 

130 

145 

160 

175 

190 

205 

220 

7212.5  7207.7 7186.1  7178.1  7162.6  7149.0  7132.1 7119.4 7101.3

K

Algo. 

KM-LPC
(Random)

100 

115 

130 

145 

160 

175 

190 

205 

220 

915.1 653.5 935.5 1320.2 1396.1 1459.5

1576  1182.4  1431 

KM-LPC 
(Degree) 

7211.0  7206.8 7191.6  7177.1  7154.8  7144.1  7130.2 7118.5 7098.9 KM-LPC
(Degree)

518.3 643.6 743.8 811.4  879.1  1048  1152.2  1258.7  1604.8 

Table 3. The values of the objective functionby  
varying the values of K and U 

   K 

U 

100 

115 

130 

145 

160 

175 

190 

205 

220 

1  7211.0  7206.8  7191.6 7177.1  7154.8  7144.1  7130.2 7118.5 7098.9

2  7210.9  7205.5  7189.6 7174.6  7159.7  7143.7  7130.1 7115.7 7099.0

3  7210.7  7205.3  7190.3 7173.4  7159.3  7143.4  7127.8 7112.1 7097.2

)
s
(
e
m
T

i

7400
6400
5400
4400
3400
2400
1400
400

U=1
U=2
U=3

100 115 130 145 160 175 190 205 220 K

 

 

Fig. 5. The running time of Exp. 3 

4.2.3   Property Study of the Discovered Link Pattern-Based Communities 
[Exp. 4]. The parameter U is set to be 1 and the value of K is varied from 25 to 200. 
In  addition,  KM-LPC  is  performed  by  combined  with  the  picking  by  node  degree 
strategy.  Suppose  a  node  vx  belongs  to  a  community  Ci.  The  intra-community-
interaction of node vx is defined to be the sum of the weights of the edges between vx 
and all the other nodes belonging to Ci divided by the sum of the weights of all edges 
of  vx.  A  node  with  a  high  value  of  the  intra-community-interaction  implies  that  the 
edges of the node mainly connect to the other nodes within the same community. In 
this experiment, the property of the discovered communities is studied by measuring 
the average intra-community-interaction of the nodes in the graph. When the values of 
K  are  set  to  be  200,  100,  50,  and  25,  the  values  of  the  obtained  average  intra-
community-interaction are 0.70, 0.79, 0.84, and 0.91, respectively. It is indicated that 
the value of the average intra-community-interaction tends upwards by decreasing the 
value of K. 

By analyzing the discovered communities by KM-LPC in detail, when a small value 
of K is given, most of the communities have dense connections within the community 
and  sparse  connections  with  other  communities.  However,  when  the  value  of  K  be-
comes as large as 200, two different types of communities are observed. The first type 
of  communities  has  dense  connections  within  the  community.  Although  the  second 
type of communities has sparse connections within the community, the nodes in each 
community consistently connect to the nodes in a certain set of dense communities. 

According to the semantics of the dataset, the authors assigned to one of the first type 
of  communities  have  strong  co-author  relationship  within  the  community.  Thus,  the 
members of a community in first type have common research topics. On the other hand, 
in  the  second  type  of  communities,  although  the  authors  cooperate  seldom  with  each 
other,  they  co-work  with  the  authors  in  the  same  set  of  the  first  type  communities. 
Therefore,  the  authors  assigned  to  a  second  type  community  also  have  the  similar 
research interests, who are potential partners with each other. This interesting finding 
 

 

A Better Strategy of Discovering Link-Pattern Based Communities 

67 

is  useful  for  authors  to  find  possible  cooperators.  Consequently,  depending  on  the 
needs of users, KM-LPC can discover the different meaningful communities by vary-
ing the value of K. 

5   Conclusions and Future Work 

In this paper, we reformulate the problem of discovering link-pattern based communi-
ties from a social network based on the similarity of link patterns of the nodes within 
each community. The problem of discovering link-pattern based communities is trans-
formed to a classical clustering problem. Two algorithms named G-LPC and KM-LPC 
are proposed based on the classical clustering methods. The experiment results with the 
real datasets demonstrate that KM-LPC is better than CLGA not only on the discov-
ered  communities  but  also  on  the  efficiency  and  memory  utilization.  Although  the 
computational cost of G-LPC is higher than the others, its result is the best approaching 
the optimal solution. Finally, in most cases, picking by node degree is a good strategy 
to select the sample nodes for deciding the initial community centroids. 

In some social networks, it is allowed that an individual belongs to multiple com-
munities. To extend the concept of link-pattern based communities in this environment 
for  identifying  the  communities  is  under  our  investigation.  Moreover,  how  to  deter-
mine a proper number of communities for discovering a set of semantically meaningful 
communities is another important issue for our future study. 

References 

1.  Chan, P.K., Schlag, M.D.F., Zien, J.Y.: Spectral K-Way Ratio-Cut Partitioning and Cluster-

ing. In: Proceedings of the 30th Design Automation Conference, pp. 749–754 (1993) 

2.  Ding, C.H.Q., He, X., Zha, H., Gu, M., Simon, H.D.: A Min-Max Cut Algorithm for Graph 
Partitioning and Data Clustering. In: Proceedings of the 1st IEEE International Conference 
on Data Mining, pp. 107–114 (2001) 

3.  Flake,  G.,  Lawrence,  S.,  Giles,  C.:  Efficient  Identification  of  Web  Communities.  In:  Pro-
ceedings of the 6th ACM SIGKDD International Conference on Knowledge Discovery and 
Data Mining, pp. 150–160 (2000) 

4.  Hartigan, J.A.: Clustering algorithms. John Wiley & Sons, New York (1975) 
5.  Ino, H., Kudo, M., Nakamura, A.: Partitioning of Web Graphs by Community Topology. In: 

Proceedings of the 14th International Conference on World Wide Web, pp. 661–669 (2005) 

6.  Kumar,  R.,  Raghavan,  P.,  Rajagopalan,  S.,  Tomkins,  A.:  Trawling  the  Web  for  Emerging 

Cyber-Communities. Journal of Computer Networks 31(11-16), 1481–1493 (1999) 

7.  Long, B., Wu, X., Zhang, Z.M., Yu, P.S.: Community Learning by Graph Approximation. 
In:  Proceedings  of  the  7th  IEEE  International  Conference  on  Data  Mining,  pp.  232–241 
(2007) 

8.  Reddy,  P.,  Kitsuregawa,  M.:  Inferring  Web  Communities  through  Relaxed  Cocitation  and 
Dense Bipartite Graphs. In: Proceedings of the 2nd International Conference on Web Infor-
mation Systems Engineering, pp. 301–310 (2001) 

9.  Shi, J., Malik, J.: Normalized Cuts and Image Segmentation. IEEE Transactions on Pattern 

Analysis and Machine Intelligence 22(8), 888–905 (2000) 


